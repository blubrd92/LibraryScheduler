<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Library Reservations</title>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        :root { 
            --primary: #2c3e50; 
            --light: #f8f9fa; 
            --border: #dee2e6; 
            --danger: #c0392b; 
            --success: #27ae60;
            
            /* Two-Tone Alternating Palette */
            --app-color-1: #5c6bc0; /* Soft Indigo */
            --app-color-2: #26a69a; /* Calm Teal */
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #fff; color: #333; }
        
        /* Utility */
        .hidden { display: none !important; }
        .flex { display: flex; align-items: center; }
        .gap { gap: 10px; }

        /* Status Bar */
        #status-bar { font-size: 0.8rem; padding: 5px; text-align: right; color: #999; margin-bottom: 10px;}
        .online { color: var(--success); font-weight: bold; }
        .offline { color: var(--danger); font-weight: bold; }

        /* Header */
        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 0px; }
        .header-title h2 { margin: 0; font-size: 1.8rem; color: var(--primary); }
        .header-title small { font-size: 1rem; color: #666; font-weight: normal; margin-left: 10px; }
        
        /* Controls */
        button { cursor: pointer; padding: 8px 14px; border: 1px solid #ccc; border-radius: 4px; background: var(--light); transition: 0.2s; font-weight: 600; }
        button:hover { background: #e2e6ea; }
        .btn-primary { background: var(--primary); color: white; border: none; }
        .btn-success { background: var(--success); color: white; border: none; }
        .btn-danger { background: white; color: var(--danger); border: 1px solid var(--danger); }
        .btn-nav { font-weight: bold; width: 40px; text-align: center; }
        select, input[type="date"], input[type="text"], input[type="number"], input[type="password"] { padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 1rem; }

        /* === UPDATED: LAYOUT WRAPPER === */
        .layout-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            height: 75vh; /* Moved height here from grid-container */
        }

        /* === NEW: SIDEBAR STYLES === */
        .info-sidebar {
            width: 250px;
            flex-shrink: 0;
            background: #f8f9fa;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0px 15px;
            height: 100%;
            overflow-y: auto;
            white-space: normal;
            box-sizing: border-box;
            font-size: 0.95rem;
            line-height: 1.5;
            color: #444;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
        }

        /* Grid */
        /* Updated height to 100% to fill the layout-wrapper */
        .grid-container { display: grid; grid-template-columns: 85px repeat(7, 1fr); border: 1px solid var(--border); height: 100%; overflow-y: auto; position: relative; background: #fff; flex-grow: 1; }
        .header-cell { 
            background: var(--primary); 
            color: white; 
            padding: 10px 5px; 
            font-weight: bold; 
            position: sticky; 
            top: 0; 
            z-index: 10; 
            border-right: 1px solid rgba(255,255,255,0.2);
            
            /* NEW: Match Time Column Size & Flex Centering */
            font-size: 0.95em;
            display: flex;
            flex-direction: column; /* Keeps the date below the day name */
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        /* Row Banding */
        .row-alt { background-color: #f0f0f0; }

        /* Time Cell Styling */
        .time-cell { 
            display: flex; align-items: center; justify-content: center;
            font-size: 0.95em; font-weight: bold; color: #555; 
            border-bottom: 1px solid #ccc; border-right: 2px solid #bbb; 
            background: #fff; position: sticky; left: 0; z-index: 5; 
        }
        .time-cell.row-alt { background-color: #f0f0f0; }
        
        /* Slots */
        .slot { 
            border-bottom: 1px dotted #ccc; 
            border-right: 1px solid #ccc; 
            padding: 2px; 
            font-size: 0.95em; 
            min-height: 25px; 
            cursor: pointer; 
            position: relative; 
            transition: background 0.1s; 
            box-sizing: border-box; 
        }
        
        .slot:not(.booked-head):not(.booked-body):not(.closed):hover { background-color: #e3f2fd; }
        
        .slot:not(.booked-head):not(.booked-body):not(.closed):hover::after {
            content: attr(data-time);
            position: absolute;
            bottom: 100%; left: 50%; transform: translateX(-50%);
            background: #333; color: #fff; padding: 4px 8px; border-radius: 4px;
            font-size: 0.85em; white-space: nowrap; pointer-events: none; z-index: 20;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .slot.closed { background-color: #cccccc !important; border-color: #cccccc; cursor: not-allowed; opacity: 1; pointer-events: none; }
        
        /* Merged Cell Styles */
        .slot.booked-head { 
            color: white; 
            border-radius: 4px; 
            padding: 6px 8px; 
            font-weight: 600; 
            z-index: 2; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column; 
            align-items: flex-start;
            justify-content: flex-start; 
            height: 100%; 
            overflow: hidden; 
        }
        
        .slot.booked-body { display: none; } 
        
        .slot.booked-head.with-staff { border-left: 5px solid #f1c40f; } 
        
        .booking-hover-effect {
            opacity: 1 !important;
            filter: brightness(1.1) saturate(1.1); 
            z-index: 15;
        }

        .bg-color-0 { background-color: var(--app-color-1); }
        .bg-color-1 { background-color: var(--app-color-2); }
        
        /* Text Styles */
        .slot-name { 
            display: block; 
            width: 100%;
            white-space: normal; 
            word-break: break-word; 
            overflow: visible; 
            font-size: 0.95em; 
            line-height: 1.3;
        }
        .slot-staff { 
            font-size: 0.9em; 
            color: rgba(255,255,255,0.9); 
            font-style: italic; 
            display: block; 
            margin-top: 2px; 
        }

        /* Modals */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(2px); }
        .modal-content { background: white; padding: 25px; border-radius: 8px; width: 400px; max-width: 90%; box-shadow: 0 15px 30px rgba(0,0,0,0.3); }
        .modal-header { font-size: 1.2rem; font-weight: bold; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9em; color: #555; }
        .form-group input, .form-group textarea, .form-group select { width: 100%; box-sizing: border-box; }
        
        /* LOGIN SCREEN */
        #loginOverlay { display: flex; position: fixed; top:0; left:0; width:100%; height:100%; background: var(--primary); z-index: 5000; justify-content: center; align-items: center; flex-direction: column; color: white; }
        .login-box { background: white; padding: 40px; border-radius: 8px; width: 300px; text-align: center; color: #333; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
        .login-box h2 { margin-top: 0; color: var(--primary); }
        .login-box input { width: 100%; padding: 12px; margin: 15px 0; font-size: 1.1rem; box-sizing: border-box; }
        .login-box button { width: 100%; padding: 12px; background: var(--success); color: white; font-size: 1.1rem; border: none; border-radius: 4px; cursor: pointer; }
        .login-box button:hover { background: #219150; }

        /* Admin Styles */
        .settings-box { background: white; padding: 0; width: 700px; max-height: 90vh; overflow-y: auto; border-radius: 8px; }
        .settings-header { background: var(--primary); color: white; padding: 15px 25px; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center; }
        .settings-body { padding: 25px; }
        .resource-manager { background: #eef2f7; padding: 15px; border-radius: 6px; border: 1px solid #d1d9e6; margin-bottom: 20px; }
        .day-config-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; margin-top: 10px; }
        .day-box { text-align: center; font-size: 0.8em; border: 1px solid #ccc; padding: 5px; border-radius: 4px; background: #fff; }
        .day-box input { text-align: center; margin-bottom: 2px; border: 1px solid #eee; }
        .day-box strong { display: block; margin-bottom: 4px; color: var(--accent); }
        .settings-row-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 15px; }
        .settings-row-grid input, .settings-row-grid select { width: 100%; box-sizing: border-box; }

        .loading-overlay { position: fixed; top:0; left:0; right:0; bottom:0; background:rgba(255,255,255,0.8); z-index: 2000; display:flex; justify-content:center; align-items:center; font-size: 2rem; color: var(--primary); font-weight:bold; }

        /* Toast Notifications */
        #toast-container { 
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 6000; 
            display: flex; flex-direction: column; gap: 10px; pointer-events: none; 
        }
        .toast { 
            padding: 12px 24px; border-radius: 6px; color: white; font-weight: 600; font-size: 1rem;
            opacity: 0; transform: translateY(20px); transition: all 0.3s ease; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.success { background-color: var(--success); }
        .toast.error { background-color: var(--danger); }

        /* Drag-and-Drop Styles */
        .slot.booked-head { cursor: grab; }
        .slot.booked-head:active { cursor: grabbing; }
        .slot.dragging { opacity: 0.5; cursor: grabbing; }
        .slot.drag-over-valid { 
            background-color: rgba(39, 174, 96, 0.3) !important; 
            box-shadow: inset 0 0 0 2px var(--success);
        }
        .slot.drag-over-invalid { 
            background-color: rgba(192, 57, 43, 0.3) !important; 
            box-shadow: inset 0 0 0 2px var(--danger);
        }
        /* Keep tooltip visible during drag */
        .slot.drag-over-valid::after,
        .slot.drag-over-invalid::after {
            content: attr(data-time);
            position: absolute;
            bottom: 100%; left: 50%; transform: translateX(-50%);
            background: #333; color: #fff; padding: 4px 8px; border-radius: 4px;
            font-size: 0.85em; white-space: nowrap; pointer-events: none; z-index: 20;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        /* Allow tooltip to overflow on booked slots during drag */
        .slot.booked-head.drag-over-valid,
        .slot.booked-head.drag-over-invalid {
            overflow: visible;
        }

        /* Drag-to-Create Selection */
        .slot.selecting {
            background-color: rgba(39, 174, 96, 0.3) !important;
        }
        .selection-overlay {
            position: fixed;
            background: rgba(39, 174, 96, 0.4);
            border: 2px solid var(--success);
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
        }
        .selection-tooltip {
            position: fixed;
            background: #333;
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            white-space: nowrap;
            z-index: 101;
            pointer-events: none;
        }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 10px;
            cursor: ns-resize;
            background: linear-gradient(to bottom, transparent, rgba(0,0,0,0.15));
            border-radius: 0 0 4px 4px;
            transition: background 0.15s;
        }
        .resize-handle:hover {
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.3));
        }
        .resize-overlay {
            position: fixed;
            background: rgba(39, 174, 96, 0.4);
            border: 2px dashed var(--success);
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
        }
        .resize-tooltip {
            position: fixed;
            background: #333;
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            white-space: nowrap;
            z-index: 101;
            pointer-events: none;
        }

        /* Move Confirmation Modal Styles */
        .move-detail { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 6px; 
            margin-bottom: 15px; 
            border: 1px solid #e9ecef;
        }
        .move-detail-row { 
            display: flex; 
            margin-bottom: 8px; 
        }
        .move-detail-row:last-child { margin-bottom: 0; }
        .move-detail-label { 
            font-weight: bold; 
            width: 80px; 
            color: #555; 
        }
        .move-detail-value { flex: 1; }
        .move-arrow { 
            text-align: center; 
            font-size: 1.5rem; 
            color: var(--primary); 
            margin: 10px 0; 
        }
    </style>
</head>
<body>

<div id="loginOverlay">
    <div class="login-box">
        <h2>Library Reservations Login</h2>
        <p>Please enter the shared access code.</p>
        <input type="password" id="loginPass" placeholder="Password" onkeydown="if(event.key==='Enter') doLogin()">
        <button onclick="doLogin()">Unlock Reservations</button>
        <p id="loginError" style="color:red; display:none; margin-top:10px;">Incorrect Password</p>
    </div>
</div>

<div id="loading" class="loading-overlay hidden">Saving...</div>

<div id="status-bar">Waiting for Login...</div>

<header>
    <div class="header-title">
        <h2 id="headerResourceName">Library Reservations</h2>
        <span id="rangeDisplay"></span>
    </div>

    <div class="flex gap">
        <select id="resourceSelect" onchange="handleResourceChange()"></select>
        
        <button class="btn-nav" onclick="navigateTime(-1)">&#8592;</button>
        <div class="date-picker-wrapper">
            <input type="date" id="datePicker" onchange="handleDatePick()">
        </div>
        <button class="btn-nav" onclick="navigateTime(1)">&#8594;</button>
        
        <div style="width: 1px; height: 30px; background: #ccc; margin: 0 10px;"></div>
        <button class="btn-primary" onclick="openAdminPanel()">⚙ Admin</button>
        <button class="btn-danger" onclick="doLogout()">Logout</button>
    </div>
</header>

<div class="layout-wrapper">
    <div id="infoSidebar" class="hidden info-sidebar"></div>
    
    <div id="gridContainer" class="grid-container"></div>
</div>

<div id="bookingModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">Booking Details</div>
        <input type="hidden" id="slotId">
        <input type="hidden" id="subRoomIndex">
        
        <div class="form-group">
            <label>Duration</label>
            <select id="bookDuration"></select>
        </div>
        
        <div class="form-group">
            <label>Event Name/Patron Name</label>
            <input type="text" id="bookName" placeholder="e.g. John Doe">
        </div>
        
        <div class="form-group" id="staffSection" style="display:none; background: #fff8e1; padding: 10px; border-radius: 4px; border: 1px solid #ffe082;">
            <div class="flex gap">
                <input type="checkbox" id="bookHasStaff" onchange="toggleStaffInput()" style="width:auto;">
                <label for="bookHasStaff" style="margin:0; font-weight:normal; cursor:pointer;">Staff Assistance Required?</label>
            </div>
            <div id="staffInputContainer" class="hidden" style="margin-top: 10px;">
                <label style="font-size:0.8em; color:#666;">Assigned Staff Member:</label>
                <input type="text" id="bookStaffName" placeholder="e.g. John">
            </div>
        </div>
        
        <div class="form-group">
            <label>Notes</label>
            <textarea id="bookNotes" rows="3"></textarea>
            <div style="margin-top: 5px; display:flex; align-items:center; gap:5px;">
                <input type="checkbox" id="bookShowNotes" style="width:auto;">
                <label for="bookShowNotes" style="margin:0; font-size:0.9em; font-weight:normal; cursor:pointer;">Show on Grid?</label>
            </div>
        </div>
        
        <div style="display: flex; justify-content: space-between; margin-top: 20px;">
            <button class="btn-success" onclick="saveBooking()">Save Booking</button>
            <button class="btn-danger" onclick="deleteBooking()">Delete</button>
            <button onclick="closeModal('bookingModal')">Cancel</button>
        </div>
    </div>
</div>

<!-- Move Confirmation Modal -->
<div id="moveModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">Confirm Reschedule</div>
        <input type="hidden" id="moveSourceId">
        <input type="hidden" id="moveTargetId">
        
        <div class="move-detail">
            <div class="move-detail-row">
                <span class="move-detail-label">Patron:</span>
                <span class="move-detail-value" id="movePatronName"></span>
            </div>
        </div>
        
        <div class="move-detail">
            <div class="move-detail-row">
                <span class="move-detail-label">From:</span>
                <span class="move-detail-value" id="moveFromTime"></span>
            </div>
        </div>
        
        <div class="move-arrow">↓</div>
        
        <div class="move-detail">
            <div class="move-detail-row">
                <span class="move-detail-label">To:</span>
                <span class="move-detail-value" id="moveToTime"></span>
            </div>
        </div>
        
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button onclick="cancelMove()">Cancel</button>
            <button class="btn-success" onclick="executeMoveBooking()">Move Booking</button>
        </div>
    </div>
</div>

<div id="settingsOverlay" class="modal">
    <div class="settings-box">
        <div class="settings-header">
            <span>Admin Configuration</span>
            <button onclick="closeModal('settingsOverlay')" style="background:transparent; border:none; color:white; font-size:1.5rem;">&times;</button>
        </div>
        <div class="settings-body">
            
            <div class="resource-manager">
                <label style="font-weight:bold; display:block; margin-bottom:5px;">Manage Resources:</label>
                <div class="flex gap">
                    <select id="settingResSelect" onchange="loadSettingsForEditor()" style="flex-grow:1;"></select>
                    <button class="btn-success" onclick="addNewResource()">+ New Resource</button>
                    <button class="btn-danger" onclick="deleteResource()">Delete</button>
                </div>
            </div>

            <div style="border-top: 1px solid #eee; padding-top: 15px;">
                <div class="settings-row-grid">
                    <div>
                        <label>Resource Name</label>
                        <input type="text" id="editResName">
                    </div>
                    <div>
                        <label>Max Hours</label>
                        <input type="number" id="editMaxDuration" step="0.5">
                    </div>
                </div>

                <div class="form-group" style="background: #e3f2fd; padding: 10px; border-radius: 4px; border: 1px solid #bbdefb;">
                    <label>View Mode</label>
                    <select id="editViewMode" onchange="toggleSubRoomInput()">
                        <option value="week">Weekly Grid (Standard)</option>
                        <option value="day">Day View (Multi-Room)</option>
                    </select>
                    
                    <div id="subRoomConfig" class="hidden" style="margin-top:10px;">
                        <label>Sub-Rooms / Columns (Comma Separated)</label>
                        <input type="text" id="editSubRooms" placeholder="e.g. Pod A, Pod B, Pod C">
                        <small style="color:#666">These will appear as columns in Day View.</small>
                    </div>
                </div>

                <div class="form-group" style="background: #fdf2e9; padding: 10px; border-radius: 4px; border: 1px solid #fae5d3;">
                    <div class="flex gap">
                        <input type="checkbox" id="editEnableSidebar" onchange="toggleSidebarConfig()" style="width:auto;">
                        <label for="editEnableSidebar" style="margin:0; cursor:pointer; font-weight:bold; color:#d35400;">Enable Sidebar Information?</label>
                    </div>
                    <div id="sidebarTextConfig" class="hidden" style="margin-top:10px;">
                        <label>Sidebar Text (Policies/Rules)</label>
                        <textarea id="editSidebarText" rows="4" placeholder="Enter policies here..."></textarea>
                    </div>
                </div>
                
                <div class="form-group" style="background: #f0f8ff; padding: 10px; border-radius: 4px; border: 1px solid #d0e1f5;">
                    <div class="flex gap">
                        <input type="checkbox" id="editResOrientation" style="width:auto;">
                        <label for="editResOrientation" style="margin:0; cursor:pointer;">Enable "Staff Assistance" Fields?</label>
                    </div>
                    <div class="flex gap" style="margin-top:8px; padding-top:8px; border-top:1px solid #d0e1f5;">
                        <input type="checkbox" id="editDefaultShowNotes" style="width:auto;">
                        <label for="editDefaultShowNotes" style="margin:0; cursor:pointer;">Default "Show Notes" to Checked?</label>
                    </div>
                </div>

                <div class="form-group">
                    <h4 style="margin: 15px 0 5px 0; border-bottom: 2px solid #eee; padding-bottom:5px;">Operating Hours (24h Format)</h4>
                    <div class="day-config-grid" id="daysConfigContainer"></div>
                </div>
            </div>
            
            <div style="text-align: right; margin-top: 20px; border-top: 1px solid #eee; padding-top: 15px;">
                <button class="btn-primary" onclick="saveAllSettings()" style="width: 200px; padding: 12px;">SAVE CHANGES</button>
            </div>
        </div>
    </div>
</div>

<div id="toast-container"></div>

<script>
    // --- FIREBASE CONFIG ---
const firebaseConfig = {
  apiKey: "AIzaSyAKLTLBTH5KaJ0DiK2AUphu1w80yJwUwTI",
  authDomain: "libraryscheduler-faf2f.firebaseapp.com",
  projectId: "libraryscheduler-faf2f",
  storageBucket: "libraryscheduler-faf2f.firebasestorage.app",
  messagingSenderId: "286899383584",
  appId: "1:286899383584:web:5826c1297f3c5bd28afb45"
};
    // --- END CONFIG ---

    if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();

    const STAFF_EMAIL = "staff@library.internal"; 
    const ADMIN_PASS = "library"; 

    const DAYS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const DEFAULT_HOURS = [0,0, 10,18, 10,20, 10,18, 10,18, 10,17, 10,17]; 

    function showToast(message, type = 'success') {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`; 
        toast.innerText = message;
        container.appendChild(toast);
        requestAnimationFrame(() => { toast.classList.add('show'); });
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300); 
        }, 3000);
    }

    // STATE
    let resources = [];
    let currentResId = null;
    let pendingSelectionId = null;
    let currentWeekStart = new Date(); 
    let currentDayDate = new Date();   
    let allBookings = {}; 
    let dailyMap = []; 
    let bookingColorMap = {};
    let activeListenerUnsub = null;

    // DRAG-AND-DROP STATE
    let dragState = {
        sourceId: null,
        sourceData: null,
        isDragging: false,
        isSaving: false
    };

    // DRAG-TO-CREATE SELECTION STATE
    let selectionState = {
        active: false,
        startSlotId: null,
        startTime: 0,
        startDayIndex: 0,
        subIndex: null,
        startY: 0,
        slotHeight: 0,
        maxDuration: 0,
        currentDuration: 0.5,
        res: null,
        activeWeekKey: null,
        startSlotRect: null,
        overlayElement: null,
        tooltipElement: null
    };

    // RESIZE STATE (for existing bookings)
    let resizeState = {
        active: false,
        bookingId: null,
        bookingData: null,
        bookingStart: 0,
        col: null,
        res: null,
        activeWeekKey: null,
        startY: 0,
        slotHeight: 0,
        originalDuration: 0,
        currentDuration: 0,
        minDuration: 0.5,
        maxDuration: 0,
        originalRect: null,
        overlayElement: null,
        tooltipElement: null
    };
    let resizeJustEnded = false;

    function init() {
        const d = new Date();
        const day = d.getDay();
        const diff = d.getDate() - day; 
        const weekStart = new Date(d);
        weekStart.setDate(diff);
        weekStart.setHours(0,0,0,0);
        currentWeekStart = weekStart;
        
        currentDayDate = new Date();
        currentDayDate.setHours(0,0,0,0);

        auth.onAuthStateChanged(user => {
            if (user) {
                document.getElementById('loginOverlay').style.display = 'none';
                document.getElementById('status-bar').innerHTML = "<span class='online'>● Connected (Staff)</span>";
                setupRealtimeListeners();
            } else {
                document.getElementById('loginOverlay').style.display = 'flex';
                document.getElementById('status-bar').innerHTML = "<span class='offline'>Locked</span>";
            }
        });
    }

    // --- AUTH ACTIONS ---
    function doLogin() {
        const pass = document.getElementById('loginPass').value;
        const err = document.getElementById('loginError');
        err.style.display = 'none';
        
        auth.signInWithEmailAndPassword(STAFF_EMAIL, pass)
            .catch(error => {
                err.style.display = 'block';
                err.innerText = "Error: " + error.message;
            });
    }

    function doLogout() {
        auth.signOut();
        location.reload();
    }

    function setupRealtimeListeners() {
        db.collection('system').doc('resources').onSnapshot((doc) => {
            if (doc.exists) {
                resources = doc.data().list || [];
            } else {
                resources = [{ id: 'res_default', name: 'General Area', viewMode: 'week', hours: DEFAULT_HOURS }];
                db.collection('system').doc('resources').set({ list: resources });
            }
            handleResourceUpdate();
        }, (err) => showToast("Permissions Error: " + err.message, "error"));
    }

    // --- CORE LOGIC ---
    function loadBookingsForCurrentView() {
        if (activeListenerUnsub) {
            activeListenerUnsub();
            activeListenerUnsub = null;
        }

        const res = resources.find(r => r.id === currentResId);
        if (!res) return;

        const activeWeekKey = getWeekKey(currentWeekStart); 
        const queryPrefix = `${res.id}_${activeWeekKey}`;

        activeListenerUnsub = db.collection('appointments')
            .where(firebase.firestore.FieldPath.documentId(), '>=', queryPrefix)
            .where(firebase.firestore.FieldPath.documentId(), '<', queryPrefix + '\uf8ff') 
            .onSnapshot((snapshot) => {
                allBookings = {}; 
                snapshot.forEach((doc) => { 
                    allBookings[doc.id] = doc.data(); 
                });
                renderGrid();
            }, (error) => {
                console.error("Data fetch error:", error);
                showToast("Sync Error: " + error.message, "error");
            });
    }
    
    function handleResourceUpdate() {
        const mainSel = document.getElementById('resourceSelect');
        const adminSel = document.getElementById('settingResSelect');

        if (!currentResId) {
            const urlParams = new URLSearchParams(window.location.search);
            const paramId = urlParams.get('resource');
            if (paramId && resources.some(r => r.id === paramId)) {
                currentResId = paramId;
            }
        }
        
        const populate = (sel, selectedId) => {
            sel.innerHTML = '';
            resources.forEach(r => {
                const opt = document.createElement('option');
                opt.value = r.id;
                opt.innerText = r.name;
                sel.appendChild(opt);
            });
            if (selectedId && resources.find(r => r.id === selectedId)) sel.value = selectedId;
        };

        if (!currentResId && resources.length > 0) currentResId = resources[0].id;
        populate(mainSel, currentResId);

        let adminVal = adminSel.value;
        if (pendingSelectionId) { adminVal = pendingSelectionId; pendingSelectionId = null; } 
        else if (!adminVal && resources.length > 0) { adminVal = resources[0].id; }
        populate(adminSel, adminVal);

        updateUIControls();
        loadBookingsForCurrentView();
        if(document.getElementById('settingsOverlay').style.display !== 'none') loadSettingsForEditor();
    }

    function navigateTime(dir) {
        const res = resources.find(r => r.id === currentResId);
        const isDayView = res && res.viewMode === 'day';
        if (isDayView) {
            currentDayDate.setDate(currentDayDate.getDate() + dir);
            const d = new Date(currentDayDate);
            const day = d.getDay();
            const diff = d.getDate() - day;
            currentWeekStart = new Date(d.setDate(diff));
        } else {
            currentWeekStart.setDate(currentWeekStart.getDate() + (dir * 7));
            currentDayDate = new Date(currentWeekStart);
        }
        updateUIControls();
        loadBookingsForCurrentView();
    }

    function handleDatePick() {
        const raw = document.getElementById('datePicker').value;
        if(!raw) return;
        const rawDate = new Date(raw + 'T00:00');
        currentDayDate = new Date(rawDate);
        const day = rawDate.getDay();
        const diff = rawDate.getDate() - day;
        currentWeekStart = new Date(rawDate.setDate(diff));
        updateUIControls();
        loadBookingsForCurrentView();
    }

    function updateUIControls() {
        const res = resources.find(x => x.id === currentResId);
        if(!res) return;
        const isDayView = res.viewMode === 'day';
        
        // --- NEW: Handle Sidebar Visibility & Text ---
        const sidebar = document.getElementById('infoSidebar');
        if (res.enableSidebar) {
            sidebar.classList.remove('hidden');
            sidebar.innerHTML = marked.parse(res.sidebarText || "");
        } else {
            sidebar.classList.add('hidden');
        }
        // ---------------------------------------------

        if (isDayView) {
            const d = currentDayDate;
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            document.getElementById('rangeDisplay').innerText = d.toLocaleDateString('en-US', options);
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            document.getElementById('datePicker').value = `${y}-${m}-${day}`;
        } else {
            const endWeek = new Date(currentWeekStart);
            endWeek.setDate(endWeek.getDate() + 6);
            document.getElementById('rangeDisplay').innerText = `${formatDateShort(currentWeekStart)} - ${formatDateShort(endWeek)}`;
            const y = currentWeekStart.getFullYear();
            const m = String(currentWeekStart.getMonth() + 1).padStart(2, '0');
            const d = String(currentWeekStart.getDate()).padStart(2, '0');
            document.getElementById('datePicker').value = `${y}-${m}-${d}`;
        }
        document.getElementById('headerResourceName').innerText = res.name;
    }

    function renderGrid() {
        const container = document.getElementById('gridContainer');
        container.innerHTML = '';
        const res = resources.find(r => r.id === currentResId);
        if(!res) return;
        const isDayView = res.viewMode === 'day';
        
        let columns = []; 
        if (isDayView) {
            const dayIdx = currentDayDate.getDay(); 
            const subRooms = res.subRooms ? res.subRooms.split(',').map(s => s.trim()).filter(s => s) : ['Main'];
            container.style.gridTemplateColumns = `85px repeat(${subRooms.length}, 1fr)`;
            subRooms.forEach((name, idx) => {
                columns.push({ header: name, date: currentDayDate, dayIndex: dayIdx, subIndex: idx });
            });
        } else {
            container.style.gridTemplateColumns = `85px repeat(7, 1fr)`;
            DAYS.forEach((name, i) => {
                const d = new Date(currentWeekStart);
                d.setDate(d.getDate() + i);
                columns.push({ header: `${name} <br><small style="font-weight:normal">${d.getMonth()+1}/${d.getDate()}</small>`, date: d, dayIndex: i, subIndex: null });
            });
        }

        container.appendChild(createDiv('header-cell', 'Time'));
        columns.forEach(col => { container.appendChild(createDiv('header-cell', col.header)); });

        const activeWeekKey = getWeekKey(isDayView ? currentDayDate : currentWeekStart);
        let gridBookings = [];
        Object.keys(allBookings).forEach(key => {
            if (key.startsWith(res.id + "_" + activeWeekKey)) {
                const prefix = res.id + "_";
                const suffix = key.substring(prefix.length); 
                const parts = suffix.split('_');
                const bkDayIdx = parseInt(parts[1]);
                const bkStart = parseFloat(parts[2]);
                const bkSubIdx = parts[3] ? parseInt(parts[3]) : null;
                gridBookings.push({ id: key, dayIndex: bkDayIdx, start: bkStart, end: bkStart + parseFloat(allBookings[key].duration), subIndex: bkSubIdx, data: allBookings[key] });
            }
        });

        bookingColorMap = {};
        let colGroups = {};
        gridBookings.forEach(b => {
            const k = b.dayIndex + "-" + (b.subIndex !== null ? b.subIndex : 'x');
            if(!colGroups[k]) colGroups[k] = [];
            colGroups[k].push(b);
        });
        Object.values(colGroups).forEach(group => {
            group.sort((a,b) => a.start - b.start);
            group.forEach((b, i) => bookingColorMap[b.id] = i % 2);
        });

        let minH = 24, maxH = 0;
        for(let i=0; i<14; i+=2) {
            if(res.hours[i] !== res.hours[i+1]) {
                if(res.hours[i] < minH) minH = res.hours[i];
                if(res.hours[i+1] > maxH) maxH = res.hours[i+1];
            }
        }
        if(minH > maxH) { minH = 9; maxH = 17; }

        const totalSlots = (maxH - minH) * 2;
        for (let i = 0; i < totalSlots; i++) {
            const timeVal = minH + (i * 0.5);
            const displayTime = formatTime(timeVal);
            const isAltRow = (i % 2 === 1);
            const rowClass = isAltRow ? 'row-alt' : '';
            
            container.appendChild(createDiv(`time-cell ${rowClass}`, displayTime));

            columns.forEach(col => {
                const dayStart = res.hours[col.dayIndex * 2];
                const dayEnd = res.hours[(col.dayIndex * 2) + 1];
                const slot = document.createElement('div');
                slot.className = `slot ${rowClass}`;
                
                if (timeVal < dayStart || timeVal >= dayEnd || dayStart === dayEnd) {
                    slot.classList.add('closed');
                    container.appendChild(slot);
                } else {
                    const booking = gridBookings.find(b => b.dayIndex === col.dayIndex && (b.subIndex === col.subIndex) && timeVal >= b.start && timeVal < b.end);
                    if (booking) {
                        const colorIndex = bookingColorMap[booking.id];
                        const colorClass = `bg-color-${colorIndex}`;
                        slot.dataset.bid = booking.id;
                        slot.onmouseenter = () => highlightBooking(booking.id);
                        slot.onmouseleave = () => unhighlightBooking(booking.id);

                        if (timeVal === booking.start) {
                            const spanCount = booking.data.duration * 2; 
                            slot.style.gridRow = `span ${spanCount}`;
                            slot.style.height = "100%"; 
                            
                            slot.className = `slot ${rowClass} booked-head ${colorClass}`;
                            if(booking.data.hasStaff) slot.classList.add('with-staff');
                            
                            slot.innerHTML = `<span class="slot-name">${escapeHtml(booking.data.name)} <span style="font-weight:normal; font-size:0.9em; opacity:0.9">(${formatTime(booking.start)} - ${formatTime(booking.end)})</span></span>`;
                            
                            if(booking.data.hasStaff) {
                                slot.innerHTML += `<span class="slot-staff">w/ ${escapeHtml(booking.data.staffName)}</span>`;
                            }
                            
                            if(booking.data.showNotes && booking.data.notes) {
                                slot.innerHTML += `<span style="display:block; font-size:0.85em; margin-top:4px; opacity:0.9; border-top:1px solid rgba(255,255,255,0.2); padding-top:2px;">${escapeHtml(booking.data.notes)}</span>`;
                            }

                            // Add resize handle
                            const resizeHandle = document.createElement('div');
                            resizeHandle.className = 'resize-handle';
                            resizeHandle.onmousedown = (e) => startResize(e, booking, col, res, activeWeekKey, slot);
                            slot.appendChild(resizeHandle);

                            slot.onclick = (e) => {
                                // Don't open modal if clicking resize handle or just finished resizing
                                if (e.target.classList.contains('resize-handle')) return;
                                if (resizeJustEnded) return;
                                openBookingModal(booking.id, booking.data, col.subIndex);
                            };
                            
                            // DRAG-AND-DROP: Make booked slots draggable
                            slot.draggable = true;
                            slot.ondragstart = (e) => handleDragStart(e, booking.id, booking.data);
                            slot.ondragend = handleDragEnd;
                            
                            // DRAG-AND-DROP: Make booked slots drop targets for shifting
                            slot.dataset.bookingId = booking.id;
                            slot.dataset.bookingStart = booking.start;
                            slot.dataset.bookingDuration = booking.data.duration;
                            slot.dataset.dayIndex = col.dayIndex;
                            slot.dataset.subIndex = col.subIndex !== null ? col.subIndex : '';
                            slot.ondragover = (e) => handleBookedSlotDragOver(e, booking, col, res, activeWeekKey);
                            slot.ondragleave = handleDragLeave;
                            slot.ondrop = (e) => handleBookedSlotDrop(e, booking, col, res, activeWeekKey);
                            
                            container.appendChild(slot);
                        } else {
                            return; 
                        }
                    } else {
                        let emptyId = `${res.id}_${activeWeekKey}_${col.dayIndex}_${timeVal}`;
                        if (col.subIndex !== null) emptyId += `_${col.subIndex}`;
                        
                        // Click opens modal (but only if not dragging to create or just finished resizing)
                        slot.onclick = (e) => {
                            if (selectionState.active) return;
                            if (resizeJustEnded) return;
                            openBookingModal(emptyId, null, col.subIndex);
                        };
                        
                        slot.setAttribute('data-time', `${displayTime} - ${formatTime(timeVal + 0.5)}`);
                        
                        // DRAG-AND-DROP: Set up empty slots as drop targets
                        slot.dataset.slotId = emptyId;
                        slot.dataset.dayIndex = col.dayIndex;
                        slot.dataset.timeVal = timeVal;
                        slot.dataset.subIndex = col.subIndex !== null ? col.subIndex : '';
                        slot.ondragover = handleDragOver;
                        slot.ondragleave = handleDragLeave;
                        slot.ondrop = handleDrop;
                        
                        // DRAG-TO-CREATE: mousedown starts selection
                        slot.onmousedown = (e) => startSelection(e, emptyId, timeVal, col, res, activeWeekKey, slot);
                        
                        container.appendChild(slot);
                    }
                }
            });
        }
    }

    // --- DRAG-AND-DROP HANDLERS ---
    function handleDragStart(e, bookingId, bookingData) {
        // Don't start drag from resize handle
        if (e.target.classList.contains('resize-handle')) {
            e.preventDefault();
            return;
        }
        
        // Block if a move is already in progress, resize is active, or selection is active
        if (dragState.isSaving || resizeState.active || selectionState.active) {
            e.preventDefault();
            return;
        }
        
        dragState.sourceId = bookingId;
        dragState.sourceData = bookingData;
        dragState.isDragging = true;
        
        // Firefox requires setData
        e.dataTransfer.setData('text/plain', bookingId);
        e.dataTransfer.effectAllowed = 'move';
        
        // Add dragging class after a small delay to not affect the drag image
        setTimeout(() => {
            e.target.classList.add('dragging');
        }, 0);
    }

    function handleDragEnd(e) {
        dragState.isDragging = false;
        e.target.classList.remove('dragging');
        
        // Clean up any lingering drag-over classes and data-time attributes
        document.querySelectorAll('.drag-over-valid, .drag-over-invalid').forEach(el => {
            el.classList.remove('drag-over-valid', 'drag-over-invalid');
            if (el.classList.contains('booked-head')) {
                el.removeAttribute('data-time');
            }
        });
        
        // Clear drag state unless modal is open (user is confirming move)
        if (document.getElementById('moveModal').style.display !== 'flex') {
            dragState.sourceId = null;
            dragState.sourceData = null;
        }
    }

    function handleDragOver(e) {
        e.preventDefault();
        if (!dragState.isDragging || !dragState.sourceId) return;
        
        const slot = e.currentTarget;
        const targetSlotId = slot.dataset.slotId;
        
        // Remove existing classes
        slot.classList.remove('drag-over-valid', 'drag-over-invalid');
        
        // Validate the drop target
        const validation = validateDropTarget(targetSlotId);
        
        if (validation.valid) {
            slot.classList.add('drag-over-valid');
            e.dataTransfer.dropEffect = 'move';
        } else {
            slot.classList.add('drag-over-invalid');
            e.dataTransfer.dropEffect = 'none';
        }
    }

    function handleDragLeave(e) {
        const el = e.currentTarget;
        el.classList.remove('drag-over-valid', 'drag-over-invalid');
        // Clean up data-time if it was set on a booked slot during drag
        if (el.classList.contains('booked-head')) {
            el.removeAttribute('data-time');
        }
    }

    // Calculate which time slot the mouse is over within a booked element
    function getTimeSlotFromPosition(e, bookingStart, bookingDuration) {
        const rect = e.currentTarget.getBoundingClientRect();
        const relativeY = e.clientY - rect.top;
        const slotHeight = rect.height / (bookingDuration * 2); // each slot is 0.5 hours
        const slotIndex = Math.floor(relativeY / slotHeight);
        const targetTime = bookingStart + (slotIndex * 0.5);
        return targetTime;
    }

    function handleBookedSlotDragOver(e, booking, col, res, activeWeekKey) {
        e.preventDefault();
        if (!dragState.isDragging || !dragState.sourceId) return;
        
        const slot = e.currentTarget;
        slot.classList.remove('drag-over-valid', 'drag-over-invalid');
        
        // Calculate target time based on mouse position
        const targetTime = getTimeSlotFromPosition(e, booking.start, booking.data.duration);
        
        // Set data-time for tooltip display
        slot.setAttribute('data-time', `${formatTime(targetTime)} - ${formatTime(targetTime + 0.5)}`);
        
        // If dragging over a different booking, always invalid
        if (booking.id !== dragState.sourceId) {
            slot.classList.add('drag-over-invalid');
            e.dataTransfer.dropEffect = 'none';
            return;
        }
        
        // Build virtual target slot ID
        let virtualTargetId = `${res.id}_${activeWeekKey}_${col.dayIndex}_${targetTime}`;
        if (col.subIndex !== null) virtualTargetId += `_${col.subIndex}`;
        
        // Check if same slot
        if (isSameSlot(dragState.sourceId, virtualTargetId)) {
            slot.classList.add('drag-over-invalid');
            e.dataTransfer.dropEffect = 'none';
            return;
        }
        
        // Validate the virtual target
        const validation = validateDropTarget(virtualTargetId);
        
        if (validation.valid) {
            slot.classList.add('drag-over-valid');
            e.dataTransfer.dropEffect = 'move';
        } else {
            slot.classList.add('drag-over-invalid');
            e.dataTransfer.dropEffect = 'none';
        }
    }

    function handleBookedSlotDrop(e, booking, col, res, activeWeekKey) {
        e.preventDefault();
        
        const slot = e.currentTarget;
        slot.classList.remove('drag-over-valid', 'drag-over-invalid');
        slot.removeAttribute('data-time');
        
        if (!dragState.isDragging || !dragState.sourceId) return;
        
        // Only allow dropping on your own booking
        if (booking.id !== dragState.sourceId) {
            showToast("Cannot drop onto another booking.", "error");
            return;
        }
        
        // Calculate target time based on mouse position
        const targetTime = getTimeSlotFromPosition(e, booking.start, booking.data.duration);
        
        // Build virtual target slot ID
        let virtualTargetId = `${res.id}_${activeWeekKey}_${col.dayIndex}_${targetTime}`;
        if (col.subIndex !== null) virtualTargetId += `_${col.subIndex}`;
        
        // Check for same-slot drop
        if (isSameSlot(dragState.sourceId, virtualTargetId)) {
            return;
        }
        
        // Validate the drop target
        const validation = validateDropTarget(virtualTargetId);
        
        if (!validation.valid) {
            showToast(validation.reason, "error");
            return;
        }
        
        // Show confirmation modal
        showMoveConfirmation(dragState.sourceId, virtualTargetId, dragState.sourceData);
    }

    function handleDrop(e) {
        e.preventDefault();
        
        const slot = e.currentTarget;
        slot.classList.remove('drag-over-valid', 'drag-over-invalid');
        
        if (!dragState.isDragging || !dragState.sourceId) return;
        
        const targetSlotId = slot.dataset.slotId;
        
        // Check for same-slot drop
        if (isSameSlot(dragState.sourceId, targetSlotId)) {
            // Do nothing for same-slot drops
            return;
        }
        
        // Validate the drop target
        const validation = validateDropTarget(targetSlotId);
        
        if (!validation.valid) {
            showToast(validation.reason, 'error');
            return;
        }
        
        // Show confirmation modal
        showMoveConfirmation(dragState.sourceId, targetSlotId, dragState.sourceData);
    }

    function isSameSlot(sourceId, targetId) {
        const res = resources.find(r => r.id === currentResId);
        const prefix = res.id + "_";
        
        const sourceSuffix = sourceId.substring(prefix.length);
        const targetSuffix = targetId.substring(prefix.length);
        
        const sourceParts = sourceSuffix.split('_');
        const targetParts = targetSuffix.split('_');
        
        const sourceDay = parseInt(sourceParts[1]);
        const sourceTime = parseFloat(sourceParts[2]);
        const sourceSubRaw = sourceParts[3];
        const sourceSub = normalizeSubIndex(sourceSubRaw);
        
        const targetDay = parseInt(targetParts[1]);
        const targetTime = parseFloat(targetParts[2]);
        const targetSubRaw = targetParts[3];
        const targetSub = normalizeSubIndex(targetSubRaw);
        
        return sourceDay === targetDay && 
               sourceTime === targetTime && 
               sourceSub === targetSub;
    }

    function normalizeSubIndex(val) {
        if (val === null || val === undefined || val === '' || val === 'null' || val === 'undefined') {
            return null;
        }
        return parseInt(val);
    }

    function validateDropTarget(targetSlotId) {
        const res = resources.find(r => r.id === currentResId);
        const prefix = res.id + "_";
        const isDayView = res.viewMode === 'day';
        
        // Parse target slot ID
        const targetSuffix = targetSlotId.substring(prefix.length);
        const targetParts = targetSuffix.split('_');
        const targetWeekKey = targetParts[0];
        const targetDay = parseInt(targetParts[1]);
        const targetTime = parseFloat(targetParts[2]);
        const targetSubRaw = targetParts[3];
        const targetSub = normalizeSubIndex(targetSubRaw);
        
        // Parse source slot ID
        const sourceSuffix = dragState.sourceId.substring(prefix.length);
        const sourceParts = sourceSuffix.split('_');
        const sourceWeekKey = sourceParts[0];
        
        // Check week boundaries
        if (sourceWeekKey !== targetWeekKey) {
            return { valid: false, reason: "Cannot move booking to a different week." };
        }
        
        // Get operating hours for target day
        const dayStart = res.hours[targetDay * 2];
        const dayEnd = res.hours[(targetDay * 2) + 1];
        
        // Check if slot is within operating hours
        if (targetTime < dayStart || targetTime >= dayEnd || dayStart === dayEnd) {
            return { valid: false, reason: "Target slot is outside operating hours." };
        }
        
        // Check if booking duration fits before closing
        const duration = dragState.sourceData.duration;
        const bookingEnd = targetTime + duration;
        if (bookingEnd > dayEnd) {
            return { valid: false, reason: "Booking duration exceeds closing time." };
        }
        
        // Check for conflicts with existing bookings
        const activeWeekKey = getWeekKey(isDayView ? currentDayDate : currentWeekStart);
        
        for (const key of Object.keys(allBookings)) {
            // Skip the booking we're moving
            if (key === dragState.sourceId) continue;
            
            // Only check bookings for the same resource and week
            if (!key.startsWith(res.id + "_" + activeWeekKey)) continue;
            
            const kSuffix = key.substring(prefix.length);
            const kParts = kSuffix.split('_');
            const kDay = parseInt(kParts[1]);
            const kTime = parseFloat(kParts[2]);
            const kSubRaw = kParts[3];
            const kSub = normalizeSubIndex(kSubRaw);
            
            // Only check same column (same day and sub-room)
            if (kDay !== targetDay) continue;
            if (kSub !== targetSub) continue;
            
            const kDuration = allBookings[key].duration;
            const kEnd = kTime + kDuration;
            
            // Check for overlap
            if (targetTime < kEnd && bookingEnd > kTime) {
                return { valid: false, reason: "Conflicts with existing booking." };
            }
        }
        
        return { valid: true };
    }

    function showMoveConfirmation(sourceId, targetId, bookingData) {
        const res = resources.find(r => r.id === currentResId);
        const prefix = res.id + "_";
        const isDayView = res.viewMode === 'day';
        
        // Parse source
        const sourceSuffix = sourceId.substring(prefix.length);
        const sourceParts = sourceSuffix.split('_');
        const sourceDay = parseInt(sourceParts[1]);
        const sourceTime = parseFloat(sourceParts[2]);
        
        // Parse target
        const targetSuffix = targetId.substring(prefix.length);
        const targetParts = targetSuffix.split('_');
        const targetDay = parseInt(targetParts[1]);
        const targetTime = parseFloat(targetParts[2]);
        
        const duration = bookingData.duration;
        
        // Get day names and dates
        let sourceDate, targetDate;
        if (isDayView) {
            sourceDate = new Date(currentDayDate);
            targetDate = new Date(currentDayDate);
        } else {
            sourceDate = new Date(currentWeekStart);
            sourceDate.setDate(sourceDate.getDate() + sourceDay);
            targetDate = new Date(currentWeekStart);
            targetDate.setDate(targetDate.getDate() + targetDay);
        }
        
        const sourceDayName = DAYS[sourceDay];
        const targetDayName = DAYS[targetDay];
        
        const sourceFormatted = `${sourceDayName} ${sourceDate.getMonth()+1}/${sourceDate.getDate()}, ${formatTime(sourceTime)} - ${formatTime(sourceTime + duration)}`;
        const targetFormatted = `${targetDayName} ${targetDate.getMonth()+1}/${targetDate.getDate()}, ${formatTime(targetTime)} - ${formatTime(targetTime + duration)}`;
        
        // Populate modal
        document.getElementById('moveSourceId').value = sourceId;
        document.getElementById('moveTargetId').value = targetId;
        document.getElementById('movePatronName').innerText = bookingData.name;
        document.getElementById('moveFromTime').innerText = sourceFormatted;
        document.getElementById('moveToTime').innerText = targetFormatted;
        
        // Show modal
        document.getElementById('moveModal').style.display = 'flex';
    }

    // --- DRAG-TO-CREATE HANDLERS ---
    function startSelection(e, slotId, timeVal, col, res, activeWeekKey, slotElement) {
        // Only start on left click, not during other operations
        if (e.button !== 0) return;
        if (dragState.isSaving || dragState.isDragging || resizeState.active || selectionState.active) return;
        if (resizeJustEnded) return;
        
        e.preventDefault();
        
        // Calculate max duration based on closing time and collisions
        const dayEnd = res.hours[(col.dayIndex * 2) + 1];
        const maxByClose = dayEnd - timeVal;
        const maxByResource = res.maxDuration;
        
        // Find next booking in same column
        let nextBookingStart = dayEnd;
        const prefix = res.id + "_";
        Object.keys(allBookings).forEach(key => {
            if (!key.startsWith(prefix + activeWeekKey)) return;
            
            const kSuffix = key.substring(prefix.length);
            const kParts = kSuffix.split('_');
            const kDay = parseInt(kParts[1]);
            const kTime = parseFloat(kParts[2]);
            const kSubRaw = kParts[3];
            const kSub = normalizeSubIndex(kSubRaw);
            
            if (kDay !== col.dayIndex) return;
            if (kSub !== normalizeSubIndex(col.subIndex)) return;
            
            if (kTime >= timeVal && kTime < nextBookingStart) {
                nextBookingStart = kTime;
            }
        });
        
        const maxByCollision = nextBookingStart - timeVal;
        const maxDuration = Math.min(maxByClose, maxByResource, maxByCollision);
        
        if (maxDuration < 0.5) return;
        
        const rect = slotElement.getBoundingClientRect();
        
        selectionState = {
            active: true,
            startSlotId: slotId,
            startTime: timeVal,
            startDayIndex: col.dayIndex,
            subIndex: col.subIndex,
            startY: e.clientY,
            slotHeight: rect.height,
            maxDuration: maxDuration,
            currentDuration: 0.5,
            res: res,
            activeWeekKey: activeWeekKey,
            startSlotRect: rect,
            overlayElement: null,
            tooltipElement: null
        };
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'selection-overlay';
        overlay.style.left = rect.left + 'px';
        overlay.style.top = rect.top + 'px';
        overlay.style.width = rect.width + 'px';
        overlay.style.height = rect.height + 'px';
        document.body.appendChild(overlay);
        selectionState.overlayElement = overlay;
        
        // Create tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'selection-tooltip';
        tooltip.innerText = `${formatTime(timeVal)} - ${formatTime(timeVal + 0.5)} (0.5h)`;
        tooltip.style.left = (rect.right + 10) + 'px';
        tooltip.style.top = rect.top + 'px';
        document.body.appendChild(tooltip);
        selectionState.tooltipElement = tooltip;
        
        document.addEventListener('mousemove', doSelection);
        document.addEventListener('mouseup', endSelection);
    }
    
    function doSelection(e) {
        if (!selectionState.active) return;
        
        const deltaY = e.clientY - selectionState.startY;
        const slotsDelta = Math.floor(deltaY / selectionState.slotHeight);
        let newDuration = 0.5 + (slotsDelta * 0.5);
        newDuration = Math.max(0.5, Math.min(selectionState.maxDuration, newDuration));
        
        selectionState.currentDuration = newDuration;
        
        if (selectionState.overlayElement) {
            const newHeight = selectionState.slotHeight * (newDuration * 2);
            selectionState.overlayElement.style.height = newHeight + 'px';
        }
        
        if (selectionState.tooltipElement) {
            const endTime = selectionState.startTime + newDuration;
            selectionState.tooltipElement.innerText = `${formatTime(selectionState.startTime)} - ${formatTime(endTime)} (${newDuration}h)`;
        }
    }
    
    function endSelection(e) {
        if (!selectionState.active) return;
        
        document.removeEventListener('mousemove', doSelection);
        document.removeEventListener('mouseup', endSelection);
        
        if (selectionState.overlayElement) {
            selectionState.overlayElement.remove();
        }
        if (selectionState.tooltipElement) {
            selectionState.tooltipElement.remove();
        }
        
        const duration = selectionState.currentDuration;
        const slotId = selectionState.startSlotId;
        const subIndex = selectionState.subIndex;
        
        selectionState = {
            active: false,
            startSlotId: null,
            startTime: 0,
            startDayIndex: 0,
            subIndex: null,
            startY: 0,
            slotHeight: 0,
            maxDuration: 0,
            currentDuration: 0.5,
            res: null,
            activeWeekKey: null,
            startSlotRect: null,
            overlayElement: null,
            tooltipElement: null
        };
        
        openBookingModalWithDuration(slotId, subIndex, duration);
    }
    
    function openBookingModalWithDuration(slotId, subIndex, presetDuration) {
        const modal = document.getElementById('bookingModal');
        const res = resources.find(r => r.id === currentResId);
        
        const prefix = res.id + "_";
        const suffix = slotId.substring(prefix.length);
        const parts = suffix.split('_');
        const dayIdx = parseInt(parts[1]);
        const start = parseFloat(parts[2]);
        
        document.getElementById('subRoomIndex').value = (subIndex !== null && subIndex !== undefined) ? subIndex : '';

        const dayEnd = res.hours[(dayIdx * 2) + 1];
        const activeWeekKey = parts[0];
        const currentSubIdx = document.getElementById('subRoomIndex').value;
        let conflictingStarts = [];
        
        Object.keys(allBookings).forEach(k => {
            if (k.startsWith(res.id + "_" + activeWeekKey) && k !== slotId) {
                const pSuffix = k.substring(prefix.length);
                const p = pSuffix.split('_');
                const bDay = parseInt(p[1]);
                const bStart = parseFloat(p[2]);
                const bSub = p[3];
                
                if (bDay === dayIdx) {
                    const subMatch = (bSub == currentSubIdx) || (!bSub && !currentSubIdx);
                    if (subMatch) { if (bStart > start) conflictingStarts.push(bStart); }
                }
            }
        });
        
        conflictingStarts.sort((a,b) => a - b);
        const nextStart = conflictingStarts.length > 0 ? conflictingStarts[0] : dayEnd;
        const maxAvailable = nextStart - start;
        const limit = Math.min(maxAvailable, res.maxDuration);

        document.getElementById('slotId').value = slotId;
        document.getElementById('bookName').value = '';
        document.getElementById('bookNotes').value = '';
        document.getElementById('bookShowNotes').checked = res.defaultShowNotes || false;

        const showStaff = res.hasStaffField;
        document.getElementById('staffSection').style.display = showStaff ? 'block' : 'none';
        document.getElementById('bookHasStaff').checked = false;
        document.getElementById('bookStaffName').value = '';
        toggleStaffInput();

        const durSel = document.getElementById('bookDuration');
        durSel.innerHTML = '';
        const maxIterations = res.maxDuration * 2;
        for (let i = 1; i <= maxIterations; i++) {
            const val = i * 0.5;
            if (val > limit) continue;
            const opt = document.createElement('option');
            opt.value = val;
            const endVal = start + val;
            opt.innerText = `${val} ${val === 1 ? "Hour" : "Hours"} (${formatTime(start)} - ${formatTime(endVal)})`;
            if (val === presetDuration) opt.selected = true;
            durSel.appendChild(opt);
        }
        if (durSel.options.length === 0) {
            const opt = document.createElement('option');
            opt.innerText = "No time available";
            durSel.appendChild(opt);
        }
        
        modal.style.display = 'flex';
        document.getElementById('bookName').focus();
    }

    function cancelMove() {
        closeModal('moveModal');
        // Clear drag state on cancel
        dragState.sourceId = null;
        dragState.sourceData = null;
    }

    // --- RESIZE HANDLERS ---
    function startResize(e, booking, col, res, activeWeekKey, slotElement) {
        e.preventDefault();
        e.stopPropagation();
        
        // Block if saving or another operation is active
        if (dragState.isSaving || dragState.isDragging || resizeState.active || selectionState.active) return;
        
        // Calculate max duration based on closing time and collisions
        const dayEnd = res.hours[(col.dayIndex * 2) + 1];
        const maxByClose = dayEnd - booking.start;
        const maxByResource = res.maxDuration;
        
        // Find next booking in same column
        let nextBookingStart = dayEnd;
        const prefix = res.id + "_";
        Object.keys(allBookings).forEach(key => {
            if (key === booking.id) return;
            if (!key.startsWith(prefix + activeWeekKey)) return;
            
            const kSuffix = key.substring(prefix.length);
            const kParts = kSuffix.split('_');
            const kDay = parseInt(kParts[1]);
            const kTime = parseFloat(kParts[2]);
            const kSubRaw = kParts[3];
            const kSub = normalizeSubIndex(kSubRaw);
            
            if (kDay !== col.dayIndex) return;
            if (kSub !== normalizeSubIndex(col.subIndex)) return;
            
            // Only consider bookings that start after this one
            if (kTime > booking.start && kTime < nextBookingStart) {
                nextBookingStart = kTime;
            }
        });
        
        const maxByCollision = nextBookingStart - booking.start;
        const maxDuration = Math.min(maxByClose, maxByResource, maxByCollision);
        
        const rect = slotElement.getBoundingClientRect();
        const slotHeight = rect.height / (booking.data.duration * 2);
        
        resizeState = {
            active: true,
            bookingId: booking.id,
            bookingData: booking.data,
            bookingStart: booking.start,
            col: col,
            res: res,
            activeWeekKey: activeWeekKey,
            startY: e.clientY,
            slotHeight: slotHeight,
            originalDuration: booking.data.duration,
            currentDuration: booking.data.duration,
            minDuration: 0.5,
            maxDuration: maxDuration,
            originalRect: rect,
            overlayElement: null,
            tooltipElement: null
        };
        
        // Create overlay positioned over the booking
        const overlay = document.createElement('div');
        overlay.className = 'resize-overlay';
        overlay.style.left = rect.left + 'px';
        overlay.style.top = rect.top + 'px';
        overlay.style.width = rect.width + 'px';
        overlay.style.height = rect.height + 'px';
        document.body.appendChild(overlay);
        resizeState.overlayElement = overlay;
        
        // Create tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'resize-tooltip';
        tooltip.innerText = `${formatTime(booking.start)} - ${formatTime(booking.start + booking.data.duration)} (${booking.data.duration}h)`;
        tooltip.style.left = (rect.right + 10) + 'px';
        tooltip.style.top = rect.top + 'px';
        document.body.appendChild(tooltip);
        resizeState.tooltipElement = tooltip;
        
        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', endResize);
    }
    
    function doResize(e) {
        if (!resizeState.active) return;
        
        const deltaY = e.clientY - resizeState.startY;
        const slotsDelta = Math.round(deltaY / resizeState.slotHeight);
        const durationDelta = slotsDelta * 0.5;
        
        let newDuration = resizeState.originalDuration + durationDelta;
        newDuration = Math.max(resizeState.minDuration, Math.min(resizeState.maxDuration, newDuration));
        newDuration = Math.round(newDuration * 2) / 2;
        
        resizeState.currentDuration = newDuration;
        
        // Update overlay height (not the actual grid element)
        if (resizeState.overlayElement) {
            const newHeight = resizeState.slotHeight * (newDuration * 2);
            resizeState.overlayElement.style.height = newHeight + 'px';
        }
        
        // Update tooltip
        if (resizeState.tooltipElement) {
            const newEndTime = resizeState.bookingStart + newDuration;
            resizeState.tooltipElement.innerText = `${formatTime(resizeState.bookingStart)} - ${formatTime(newEndTime)} (${newDuration}h)`;
        }
    }
    
    async function endResize(e) {
        if (!resizeState.active) return;
        
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', endResize);
        
        // Set flag to prevent accidental clicks, clear after event loop settles
        resizeJustEnded = true;
        setTimeout(() => { resizeJustEnded = false; }, 100);
        
        // Clean up overlay and tooltip
        if (resizeState.overlayElement) {
            resizeState.overlayElement.remove();
        }
        if (resizeState.tooltipElement) {
            resizeState.tooltipElement.remove();
        }
        
        const newDuration = resizeState.currentDuration;
        const bookingId = resizeState.bookingId;
        const bookingData = resizeState.bookingData;
        const originalDuration = resizeState.originalDuration;
        
        // Reset state
        resizeState = {
            active: false,
            bookingId: null,
            bookingData: null,
            bookingStart: 0,
            col: null,
            res: null,
            activeWeekKey: null,
            startY: 0,
            slotHeight: 0,
            originalDuration: 0,
            currentDuration: 0,
            minDuration: 0.5,
            maxDuration: 0,
            originalRect: null,
            overlayElement: null,
            tooltipElement: null
        };
        
        // Only save if duration actually changed
        if (newDuration !== originalDuration) {
            dragState.isSaving = true;
            showLoading(true);
            
            try {
                const updatedData = { ...bookingData, duration: newDuration };
                await db.collection('appointments').doc(bookingId).set(updatedData);
                showToast(`Duration updated to ${newDuration} hour${newDuration === 1 ? '' : 's'}`, 'success');
            } catch (error) {
                console.error("Resize error:", error);
                showToast("Failed to update duration: " + error.message, "error");
            } finally {
                dragState.isSaving = false;
                showLoading(false);
            }
        }
    }

    async function executeMoveBooking() {
        if (dragState.isSaving) return;
        
        const sourceId = document.getElementById('moveSourceId').value;
        const targetId = document.getElementById('moveTargetId').value;
        
        if (!sourceId || !targetId || !allBookings[sourceId]) {
            showToast("Invalid booking data.", "error");
            closeModal('moveModal');
            return;
        }
        
        dragState.isSaving = true;
        showLoading(true);
        closeModal('moveModal');
        
        try {
            // Copy booking data
            const bookingData = { ...allBookings[sourceId] };
            
            // Use batch write for atomic operation
            const batch = db.batch();
            
            // Delete old document
            const oldRef = db.collection('appointments').doc(sourceId);
            batch.delete(oldRef);
            
            // Create new document with same data
            const newRef = db.collection('appointments').doc(targetId);
            batch.set(newRef, bookingData);
            
            await batch.commit();
            
            showToast("Booking moved successfully!", "success");
        } catch (error) {
            console.error("Move error:", error);
            showToast("Failed to move booking: " + error.message, "error");
        } finally {
            dragState.isSaving = false;
            dragState.sourceId = null;
            dragState.sourceData = null;
            showLoading(false);
        }
    }

    // --- MODAL & SAVE ---
    function openBookingModal(slotId, data, subIdx) {
        const modal = document.getElementById('bookingModal');
        const res = resources.find(r => r.id === currentResId);
        
        const prefix = res.id + "_";
        const suffix = slotId.substring(prefix.length); 
        const parts = suffix.split('_');
        
        let start, dayIdx;
        if (data) {
             dayIdx = parseInt(parts[1]);
             start = parseFloat(parts[2]);
             document.getElementById('subRoomIndex').value = parts[3] || ''; 
        } else {
             dayIdx = parseInt(parts[1]);
             start = parseFloat(parts[2]);
             document.getElementById('subRoomIndex').value = (subIdx !== null && subIdx !== undefined) ? subIdx : '';
        }

        const dayEnd = res.hours[(dayIdx * 2) + 1];
        const activeWeekKey = parts[0];
        const currentSubIdx = document.getElementById('subRoomIndex').value;
        let conflictingStarts = [];
        
        Object.keys(allBookings).forEach(k => {
             if (k.startsWith(res.id + "_" + activeWeekKey) && k !== slotId) {
                 const pSuffix = k.substring(prefix.length);
                 const p = pSuffix.split('_');
                 const bDay = parseInt(p[1]);
                 const bStart = parseFloat(p[2]);
                 const bSub = p[3]; 
                 
                 if (bDay === dayIdx) {
                     const subMatch = (bSub == currentSubIdx) || (!bSub && !currentSubIdx);
                     if (subMatch) { if (bStart > start) conflictingStarts.push(bStart); }
                 }
             }
        });
        
        conflictingStarts.sort((a,b)=>a-b);
        const nextStart = conflictingStarts.length > 0 ? conflictingStarts[0] : dayEnd;
        const maxAvailable = nextStart - start;
        const limit = Math.min(maxAvailable, res.maxDuration);

        document.getElementById('slotId').value = slotId;
        document.getElementById('bookName').value = data ? data.name : '';
        document.getElementById('bookNotes').value = data ? data.notes : '';
        
        document.getElementById('bookShowNotes').checked = data ? (data.showNotes || false) : (res.defaultShowNotes || false);

        const showStaff = res.hasStaffField;
        document.getElementById('staffSection').style.display = showStaff ? 'block' : 'none';
        if(data) {
             document.getElementById('bookHasStaff').checked = data.hasStaff;
             document.getElementById('bookStaffName').value = data.staffName || '';
        } else {
             document.getElementById('bookHasStaff').checked = false;
             document.getElementById('bookStaffName').value = '';
        }
        toggleStaffInput();

        const durSel = document.getElementById('bookDuration');
        durSel.innerHTML = '';
        const maxIterations = res.maxDuration * 2; 
        for(let i=1; i<=maxIterations; i++) {
            const val = i*0.5;
            if (val > limit && (!data || data.duration !== val)) continue;
            const opt = document.createElement('option');
            opt.value = val;

            // --- UPDATED: Range Format (Option 2) ---
            const endVal = start + val;
            const startString = formatTime(start); 
            const endString = formatTime(endVal);
            
            // Result: "1.5 Hours (2:00pm - 3:30pm)"
            opt.innerText = `${val} ${val === 1 ? "Hour" : "Hours"} (${startString} - ${endString})`;
            // ----------------------------------------
            
            if(data && data.duration == val) opt.selected = true;
            durSel.appendChild(opt);
        }
        if(durSel.options.length === 0) { const opt = document.createElement('option'); opt.innerText = "No time available"; durSel.appendChild(opt); }
        modal.style.display = 'flex';
    }

    async function saveBooking() {
        const slotId = document.getElementById('slotId').value;
        const name = document.getElementById('bookName').value;
        const duration = parseFloat(document.getElementById('bookDuration').value);
        
        if(!name.trim()) return showToast("Please enter a name.", "error");
        if(isNaN(duration)) return showToast("Invalid duration.", "error");

        const hasStaff = document.getElementById('bookHasStaff').checked;
        const staffName = document.getElementById('bookStaffName').value;
        if (document.getElementById('staffSection').style.display !== 'none' && hasStaff && !staffName.trim()) {
            return showToast("Staff Name is required.", "error");
        }

        const res = resources.find(r => r.id === currentResId);
        const prefix = res.id + "_";
        const suffix = slotId.substring(prefix.length); 
        const parts = suffix.split('_');
        const start = parseFloat(parts[2]);
        const dayIdx = parseInt(parts[1]);

        const subIdx = parts[3] ? parseInt(parts[3]) : null;
        const dayEnd = res.hours[(dayIdx * 2) + 1];
        
        if (start + duration > dayEnd) return showToast("Exceeds closing time.", "error");

        const end = start + duration;
        let conflictFound = false;

        Object.keys(allBookings).forEach(key => {
            if (key === slotId) return;

            const kSuffix = key.substring(prefix.length);
            const kParts = kSuffix.split('_');
            
            if (!key.startsWith(prefix)) return; 

            const kDay = parseInt(kParts[1]);
            const kSub = kParts[3] ? parseInt(kParts[3]) : null;

            if (kDay !== dayIdx) return;
            if (kSub != subIdx) return; 

            const bStart = parseFloat(kParts[2]);
            const bDuration = allBookings[key].duration;
            const bEnd = bStart + bDuration;

            if (start < bEnd && end > bStart) {
                conflictFound = true;
            }
        });

        if (conflictFound) {
            return showToast("Conflict: Time overlaps with another booking.", "error");
        }
        
        const showNotes = document.getElementById('bookShowNotes').checked;

        const data = { 
            name: name, 
            notes: document.getElementById('bookNotes').value, 
            duration: duration, 
            hasStaff: hasStaff, 
            staffName: staffName,
            showNotes: showNotes 
        };

        showLoading(true);
        try { await db.collection('appointments').doc(slotId).set(data); closeModal('bookingModal'); } 
        catch(e) { showToast("Error: " + e.message, "error"); }
        showLoading(false);
    }

    function openAdminPanel() { 
        const pass = prompt("Enter Admin Password:");
        if (pass !== ADMIN_PASS) return pass ? showToast("Incorrect Password.", "error") : null;
        document.getElementById('settingsOverlay').style.display = 'flex'; 
        document.getElementById('settingResSelect').value = currentResId; 
        loadSettingsForEditor(); 
    }
    
    function loadSettingsForEditor() {
        const editId = document.getElementById('settingResSelect').value;
        const r = resources.find(x => x.id === editId);
        if(!r) return;
        document.getElementById('editResName').value = r.name;
        document.getElementById('editMaxDuration').value = r.maxDuration;
        document.getElementById('editResOrientation').checked = r.hasStaffField || false;
        document.getElementById('editViewMode').value = r.viewMode || 'week';
        document.getElementById('editSubRooms').value = r.subRooms || '';
        document.getElementById('editDefaultShowNotes').checked = r.defaultShowNotes || false;
        
        // --- NEW: Load Sidebar Settings ---
        document.getElementById('editEnableSidebar').checked = r.enableSidebar || false;
        document.getElementById('editSidebarText').value = r.sidebarText || '';
        toggleSidebarConfig(); // show/hide the text box
        // ----------------------------------

        toggleSubRoomInput();
        const container = document.getElementById('daysConfigContainer');
        container.innerHTML = '';
        DAYS.forEach((d, i) => {
            const start = r.hours[i*2];
            const end = r.hours[(i*2)+1];
            container.innerHTML += `<div class="day-box"><strong>${d}</strong><input type="number" id="s_${i}" value="${start}" min="0" max="24" step="0.5"><input type="number" id="e_${i}" value="${end}" min="0" max="24" step="0.5"></div>`;
            });
    }
    
    function toggleSubRoomInput() { const mode = document.getElementById('editViewMode').value; const container = document.getElementById('subRoomConfig'); if (mode === 'day') { container.classList.remove('hidden'); } else { container.classList.add('hidden'); } }

    // --- NEW: Toggle Sidebar Input Helper ---
    function toggleSidebarConfig() {
        const isEnabled = document.getElementById('editEnableSidebar').checked;
        const container = document.getElementById('sidebarTextConfig');
        if (isEnabled) container.classList.remove('hidden');
        else container.classList.add('hidden');
    }
    
    async function addNewResource() {
        const name = prompt("Name for new resource?");
        if(!name) return;
        showLoading(true);
        // Added defaults for sidebar
        const newRes = { 
            id: 'res-' + Date.now(), 
            name: name, 
            viewMode: 'week', 
            hasStaffField: false, 
            defaultShowNotes: false, 
            enableSidebar: false, 
            sidebarText: "",
            maxDuration: 2, 
            hours: [...DEFAULT_HOURS] 
        };
        try { await db.collection('system').doc('resources').set({ list: [...resources, newRes] }); pendingSelectionId = newRes.id; } 
        catch (e) { showToast("Error: " + e.message, "error"); }
        showLoading(false);
    }
    
    async function deleteResource() {
        const delId = document.getElementById('settingResSelect').value;
        if(!delId || !confirm("Delete this resource?")) return;
        showLoading(true);
        try { await db.collection('system').doc('resources').set({ list: resources.filter(r => r.id !== delId) }); } 
        catch (e) { showToast("Error: " + e.message, "error"); }
        showLoading(false);
    }
    
    async function saveAllSettings() {
        const editId = document.getElementById('settingResSelect').value;
        const r = resources.find(x => x.id === editId);
        if(!r) return;
        const updatedList = JSON.parse(JSON.stringify(resources));
        const target = updatedList.find(x => x.id === editId);
        target.name = document.getElementById('editResName').value;
        target.maxDuration = parseFloat(document.getElementById('editMaxDuration').value) || 2;
        target.hasStaffField = document.getElementById('editResOrientation').checked;
        target.viewMode = document.getElementById('editViewMode').value;
        target.subRooms = document.getElementById('editSubRooms').value;
        target.defaultShowNotes = document.getElementById('editDefaultShowNotes').checked;

        // --- NEW: Save Sidebar Settings ---
        target.enableSidebar = document.getElementById('editEnableSidebar').checked;
        target.sidebarText = document.getElementById('editSidebarText').value;

        for(let i=0; i<7; i++) { target.hours[i*2] = parseFloat(document.getElementById(`s_${i}`).value) || 0; target.hours[(i*2)+1] = parseFloat(document.getElementById(`e_${i}`).value) || 0; }
        showLoading(true);
        try { await db.collection('system').doc('resources').set({ list: updatedList }); showToast("Settings Saved!", "success"); } 
        catch (e) { showToast("Error: " + e.message, "error"); }
        showLoading(false);
    }
    
    function handleResourceChange() { 
        currentResId = document.getElementById('resourceSelect').value; 

        const url = new URL(window.location);
        url.searchParams.set('resource', currentResId);
        window.history.pushState({}, '', url);
        
        updateUIControls(); 
        
        loadBookingsForCurrentView(); 
    }
    function highlightBooking(id) { document.querySelectorAll(`.slot[data-bid="${id}"]`).forEach(s => s.classList.add('booking-hover-effect')); }
    function unhighlightBooking(id) { document.querySelectorAll(`.slot[data-bid="${id}"]`).forEach(s => s.classList.remove('booking-hover-effect')); }
    
    async function deleteBooking() { 
        const slotId = document.getElementById('slotId').value;
        if(!allBookings[slotId]) return closeModal('bookingModal');
        if(confirm("Delete booking?")) { 
            showLoading(true); 
            try {
                await db.collection('appointments').doc(slotId).delete();
                closeModal('bookingModal');
            } catch(e) {
                showToast("Error deleting: " + e.message, "error");
            }
            showLoading(false); 
        }
    }
    
    function closeModal(id) { document.getElementById(id).style.display = 'none'; }
    function createDiv(cls, content) { const d = document.createElement('div'); d.className = cls; d.innerHTML = content; return d; }
    function showLoading(show) { document.getElementById('loading').className = show ? 'loading-overlay' : 'loading-overlay hidden'; }
    function toggleStaffInput() { const isChecked = document.getElementById('bookHasStaff').checked; document.getElementById('staffInputContainer').classList.toggle('hidden', !isChecked); }
    function getWeekKey(d) {
        const d2 = new Date(d);
        const day = d2.getDay();
        const diff = d2.getDate() - day;
        const s = new Date(d2.setDate(diff));
        return `${s.getFullYear()}-${String(s.getMonth()+1).padStart(2,'0')}-${String(s.getDate()).padStart(2,'0')}`;
    }
    function formatDateShort(d) { return (d.getMonth()+1) + "/" + d.getDate(); }
    function escapeHtml(str) {
        if (!str) return '';
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    }
    function formatTime(val) {
        const h = Math.floor(val);
        const m = (val % 1 === 0) ? '00' : '30';
        const suffix = h >= 12 ? 'pm' : 'am';
        const h12 = h % 12 || 12;
        return `${h12}:${m}${suffix}`;
    }

    init();
</script>
</body>
</html>
